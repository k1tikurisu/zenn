---
title: "（仮）TypeScript 5.5 Betaで入った正規表現リテラルの構文チェックについて調べてみた"
emoji: "*️⃣"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["TypeScript", "正規表現"]
published: false
publication_name: "cybozu_frontend"
---

TypeScript 5.5 Betaで、正規表現リテラルの構文チェックが導入されました。

https://devblogs.microsoft.com/typescript/announcing-typescript-5-5-beta/#regular-expression-syntax-checking

正規表現の一般的な構文ミスに対して、事前にTypeScriptがエラーを出力してくれるようになります。また、TypeScriptのコンパイラオプションで指定されたECMAScriptのターゲットバージョンよりも新しい構文を使用している場合にもエラーを出してくれるようです。

```js
let myRegex = /@typedef \{import\((?<importPath>.+)\)\.(?<importedEntity>[a-zA-Z_]+)\} \k<importedEntity>/;
//                                  ~~~~~~~~~~~~         ~~~~~~~~~~~~~~~~
// error!
// Named capturing groups are only available when targeting 'ES2018' or later.
```

この機能について、なんで導入されたの？どうやってチェックしてる？JavaScriptで実行できるけどTypeScriptでエラーになる構文はある？ESLintとのカバー範囲の違いは？など色々気になったので調べてみました。

本記事に関して、誤り等があれば指摘いただけると嬉しいです。すぐに修正・反映します。

## なぜ導入されたの？

正規表現の構文チェックがあると嬉しいよねみたいなIssueは2014年ごろに立てられています。

https://github.com/microsoft/TypeScript/issues/3432

放置気味のIssueですが、同年に2つPR^[[Add `invalid regular expression literal` error #3432 by Schmavery · Pull Request #4387 · microsoft/TypeScript](https://github.com/microsoft/TypeScript/pull/4387)]^[[Added validation for regex literals via RegExp constructor by JoshuaKGoldberg · Pull Request #35957 · microsoft/TypeScript](https://github.com/microsoft/TypeScript/pull/35957)]も出ています。両方とも、`RegExp`コンストラクタに正規表現リテラルを突っ込んで、エラーになったらエラー文を出すというものです。
ただ、`RegExp`コンストラクタに依存する方法は、Node.js v8で動かなかったり、実行環境によって動作が保証されないなど色々問題があり両方ともクローズされています。

> Now, if you wanted to go more the distance and actually check specific parts of the string against the regex grammar in the ES6 specification, then I would be more ok with that :)

クローズ時のコメントを雑に翻訳すると、修正方法がよくないだけで、ECMAScriptの仕様に準拠して構文チェックするなら良さそうみたいに書かれています。今まで放置されていたのは、特に理由があるというわけではなさそうで、Issueの盛り上がり具合含め、単にやる人がいなかったのかなという印象を受けました。

## 実際どんな感じでチェックしている？

マージされたPRを読んでいきます。

https://github.com/microsoft/TypeScript/pull/55600

diffを見ると、正規表現の構文チェックはScannerで実装されていることがわかります。TypeScript Deep DiveのScannerの項^[[Scanner | TypeScript Deep Dive](https://basarat.gitbook.io/typescript/overview/scanner)]によると、ソースコードはScannerを経由してToken Streamになり、その後Parserを通してASTに変換されるようです。

> SourceCode ~~ scanner ~~> Token Stream ~~ parser ~~> AST

つまり、トークン単位でソースコードをスキャンしていき、例えば、`/`が出てきたら正規表現としてさらに中身を解析し、特定のパターンをチェックしてエラーを報告するようなイメージで実装されています。

レビューでは、ScannerではなくParserで構文チェックのロジックを持った方が、後にASTノードを追加して詳細な解析ができるようになって良さそうみたいなコメント^[[https://github.com/microsoft/TypeScript/pull/55600#pullrequestreview-2006009388](https://github.com/microsoft/TypeScript/pull/55600#pullrequestreview-2006009388)]もありますが、パフォーマンスの懸念が優先されたようです。
マージコメントでは、今後パフォーマンスチューニング含めて、Parserやその他コンポーネントに移動されるようなことが書かれています^[[https://github.com/microsoft/TypeScript/pull/55600#issuecomment-2067402238](https://github.com/microsoft/TypeScript/pull/55600#issuecomment-2067402238)]。

## JavaScriptで実行できるけどTypeScriptでエラーになる構文はある？

追従するPRやIssue^[[https://github.com/microsoft/TypeScript/pull/58295](https://github.com/microsoft/TypeScript/pull/58295)]^[[https://github.com/microsoft/TypeScript/pull/58320](https://github.com/microsoft/TypeScript/pull/58320)]^[[https://github.com/microsoft/TypeScript/issues/58287](https://github.com/microsoft/TypeScript/issues/58287)]では、[ECMAScript Annex B](https://tc39.es/ecma262/multipage/additional-ecmascript-features-for-web-browsers.html#sec-additional-ecmascript-features-for-web-browsers_)について言及されています。Annex Bとは、」JavaScriptのレガシー挙動を定めた仕様のことで、過去のWebページの互換性を保つために実装されています。Annex Bに定められた正規表現のレガシー構文については、下記の記事が参考になります。

https://zenn.dev/qnighy/articles/1d96f2c0c662f6#%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE%E3%81%AE%E3%83%AC%E3%82%AC%E3%82%B7%E3%83%BC%E6%96%87%E6%B3%95

TypeScriptは、破壊的変更を抑えるためAnnex Bをサポートする方針のようですが、一部の構文についてはエラーを報告するようになっています。
下記のIssueでは、TSを使用した800のリポジトリに対して、5.4.5ではエラーにならず、Betaでエラーになったもののキャプチャの一部が報告されています。

https://github.com/microsoft/TypeScript/issues/58287

もとのキャプチャを見るとかなり大量のエラーが報告されていることがわかりますが、基本的にはTypeScriptのコンパイラオプションのECMAScriptのターゲットが古いことに起因するもので、それ以外はAnnex Bによるものだと書かれています。

> IMO, all of the "Octal escape sequences are not allowed" and "A decimal escape must refer to an existent capturing group" are probably indications of actual errors in user code. They're allowed in Annex B, but the user likely intended to use them as a backreference to a capture group and that's not how Annex B would treat them.

コメントの一部では、Annex Bの8進エスケープと、10進エスケープに関するエラーについて言及されています。
ここではAnnex Bの8進エスケープについて抜き出してみます。

> TODO

まだ議論されているようですが、Annex Bについては、理解して使っているなら`// @ts-ignore`してね、ということになりそうです。のちにコンパイラオプションなどでフラグによって制御できるようにしたいみたいに書かれています。

## ESLintとのカバー範囲の違いは？

ESLintはデフォルトパーサにEspreeを使用しており、有効でない正規表現についてはその時点でパースエラーになります。ESLintはその上で、ルールやプラグインによって拡張することができます。

ESLintの正規表現に関連する各種ルールには、ECMAScript準拠の正規表現パーサであるregexppが使用されています。

https://github.com/eslint-community/regexpp

これは、正規表現からESTreeより細かい単位のASTにパースし、詳細な解析が可能になるというものです。ESLintの正規表現プラグインである[eslint-plugin-regexp](https://github.com/ota-meshi/eslint-plugin-regexp)でもがっつり使用されています。eslint-plugin-regexpは、正規表現のベストプラクティスに関するルールがたくさん定められており、その中でもStrictというルールで、Annex Bについての挙動を変更できます。

## 感想

正規表現って奥が深いなと思いました。今後のTypeScriptのAnnex Bまわりのサポート内容や、ロジックの移行、パフォーマンスチューニングなども気になります。TypeScriptほど大きいOSSプロジェクトのPRをしっかり見ることは初めてでしたが、パフォーマンス周りに敏感で、その書き方ってパフォーマンスに影響あるんだ、みたいなのをレビューから知れて面白かったです（例えばデフォルト引数はパフォーマンス上よくないらしい^[[https://github.com/microsoft/TypeScript/pull/55600#discussion_r1569073347](https://github.com/microsoft/TypeScript/pull/55600#discussion_r1569073347)]）。
