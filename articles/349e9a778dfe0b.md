---
title: "TypeScript 5.5 Betaで入った正規表現リテラルの構文チェックについて調べてみた"
emoji: "*️⃣"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["TypeScript", "正規表現"]
published: false
publication_name: "cybozu_frontend"
---

TypeScript 5.5 Beta で、正規表現リテラルの構文チェックが導入されました。
この構文チェックによって、正規表現に間違いがあった場合、事前に TypeScript がエラーを出力してくれます。

https://devblogs.microsoft.com/typescript/announcing-typescript-5-5-beta/#regular-expression-syntax-checking

この機能について、次のことが気になったので調べてみました。

- どんな構文がエラーになるか
- なぜ導入されたか
- どうやってチェックしているか
- JavaScript で実行できるが TypeScript でエラーになる構文はあるか
- ESLint とのカバー範囲の違い

本記事に関して、誤り等があれば指摘いただけると嬉しいです。

## どんな構文がエラーになるか

TypeScript 5.5 Beta では、正規表現に関するエラーメッセージが 40個程度[^1]追加されています。

例えば、下記のような構文はエラーになります。

```js
// 存在しないフラグ
var re = /a/b; // エラー: Unknown regular expression flag.

// かっこの閉じ忘れ
var re = /(/; // エラー: ')' expected.

// 不明な Unicode Property の名前や値
var re = /\p{a}/u; // エラー: Unknown Unicode property name or value.
```

特にUnicode周りは構文も複雑で、エラーメッセージも多く増えている印象です。よくある間違いについては改善方法まで提示してくれるメッセージになっています。

また、TypeScriptのコンパイラオプションで指定されたECMAScriptバージョンよりも新しい構文を使用している場合もエラーを出してくれるようです。

```js
var re = /(?<ab>ab)/;
//エラー: Named capturing groups are only available when targeting 'ES2018' or later.
```

## なぜ導入されたか

正規表現の構文チェックがあると嬉しいよねみたいなIssueは2015年ごろに立てられています。

https://github.com/microsoft/TypeScript/issues/3432

同年に2つPR[^2][^3]も出ています。両方とも、`RegExp`コンストラクタに正規表現リテラルを突っ込んで、エラーになったらエラー文を出すというものです。
ただ、`RegExp`コンストラクタに依存する方法は、Node.js v8で動かなかったり、実行環境によって動作が保証されないなど色々問題があり両方ともクローズされています。

> Now, if you wanted to go more the distance and actually check specific parts of the string against the regex grammar in the ES6 specification, then I would be more ok with that :)

クローズ時のコメントを雑に翻訳すると、修正方法がよくないだけで、ECMAScriptの仕様に準拠して構文チェックするなら良さそうみたいに書かれています。今まで放置されていたのは、特に理由があるというわけではなさそうで、Issueの盛り上がり具合含め、単にやる人がいなかったのかなという印象を受けました。

## どうやってチェックしているか

マージされたPRを読んでいきます。

https://github.com/microsoft/TypeScript/pull/55600

diffを見ると、正規表現の構文チェックはScannerで実装されていることがわかります。TypeScript Deep DiveのScannerの項[^4]によると、ソースコードはScannerを経由してToken Streamになり、その後Parserを通してASTに変換されるようです。

> SourceCode ~~ scanner ~~> Token Stream ~~ parser ~~> AST

つまり、トークン単位でソースコードをスキャンしていき、例えば、`/`が出てきたら正規表現としてさらに中身を解析し、特定のパターンをチェックしてエラーを報告するようなイメージで実装されています。

例えば、不明な Unicode Property の名前や値のチェックは、このあたりに書かれています。

https://github.com/microsoft/TypeScript/blob/c38569655bb151ec351c27032fbd3ef43b8856ba/src/compiler/scanner.ts#L3454-L3533

字句解析をしていき、`\d`, `\D`, `\s`, `\S`, `\w`, `\W`の場合は、単純な文字クラスエスケープとして処理、`\P`または`\p`の場合は、Unicode 文字クラスエスケープとして処理します。次の文字が `{` ならプロパティ名の解析を開始します。その後、`nonBinaryUnicodeProperties`や`valuesOfNonBinaryUnicodeProperties`を参照して、プロパティ名や値が有効かどうかをチェックしています。ちなみに、有効なプロパティ名や値はScannerの末尾に自前で定義し管理されています[^5]。

レビューでは、ScannerではなくParserで構文チェックのロジックを持った方が、後にASTノードを追加して詳細な解析ができるようになって良さそうみたいなコメント[^6]もありますが、パフォーマンスの懸念が優先されたようです。
マージコメントでは、今後パフォーマンスチューニング含めてParserやその他コンポーネントに移動されるようなことが書かれており[^7]、今後ロジックは大きく変わるかも知れません。

## JavaScript で実行できるが TypeScript でエラーになる構文はあるか

ECMAScript仕様の構文は全てエラーにならず、それ以外はエラーになるのかはテストケースからは読み取れませんでした。PRにはTest262からテストケースが追加されていましたが、ファイル数が多すぎるため削除されたようです。

TypeScriptはStage 3移行から実装するポリシー[^8]で、現在Stage 3の[Regular Expression Pattern Modifiers](https://github.com/tc39/proposal-regexp-modifiers)は5.5 Betaで実装されていました[^9]。なので、ポリシーから外れた実装にはなっていない印象です。

また、[ECMAScript Annex B](https://tc39.es/ecma262/multipage/additional-ecmascript-features-for-web-browsers.html#sec-additional-ecmascript-features-for-web-browsers_)に記載されている構文は一部エラーになるようです[^10][^11][^12]。例えば、レガシー構文である8進エスケープはTypeScript 5.5 BetaではエラーになりますがJavaScriptでは実行可能です。

```ts
const regex = /\01/; // エラー：Octal escape sequences are not allowed. Use the syntax '\x01'.
```

Annex Bとは、JavaScriptのレガシー挙動を定めた仕様のことで、過去のWebページの互換性を保つために実装されています。Annex Bに定められた正規表現のレガシー構文については、下記の記事が参考になります。

https://zenn.dev/qnighy/articles/1d96f2c0c662f6#%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE%E3%81%AE%E3%83%AC%E3%82%AC%E3%82%B7%E3%83%BC%E6%96%87%E6%B3%95

下記のIssueでは、TSを使用した800のリポジトリに対して、5.4.5ではエラーにならず、Betaでエラーになったもののキャプチャの一部が報告されています。

https://github.com/microsoft/TypeScript/issues/58287

もとのキャプチャを見るとかなり大量のエラーが報告されていることがわかります。基本的にはTypeScriptのコンパイラオプションのECMAScriptのターゲットが古いことに起因するもので、それ以外はAnnex Bやその他レガシー構文によるものだと書かれています。

まだ議論されているようですが、Annex Bについては後方互換性のためなるべくエラーは出さないようにして、一部エラーになるものについては理解して使っているなら`// @ts-ignore`するか、後にコンパイラオプションなどでフラグによって制御できるようになるかも知れません。

## ESLint とのカバー範囲の違い

正規表現の構文チェックには、ESLintを使うことができます。ESLintはデフォルトパーサにEspreeを使用しており、有効でない正規表現についてはその時点でパースエラーになります。ESLintはその上で、各種正規表現のルールに対して[regexpp](https://github.com/eslint-community/regexpp)というライブラリを使用しASTを使った解析をしています。

ESLintのプラグインの一つである[eslint-plugin-regexp](https://github.com/ota-meshi/eslint-plugin-regexp)でもregexppは使われており、正規表現のベストプラクティスに関するルールがたくさん定められています。その中でも[regexp/strict](https://ota-meshi.github.io/eslint-plugin-regexp/rules/strict.html#regexp-strict)というルールで、Annex Bの構文を禁止できます。
このルールで禁止される構文は、一例として4つ紹介されています。

```js
/* ✗ BAD */
var foo = /}/
var foo = /{/
var foo = /]/
var foo = /\u{42}/; // It matches a string followed by 42 "u"s.
```

このうちTypeScript 5.5 Betaでエラーになるものは最後の1つだけです。レガシー構文の位置付けがどうなるのかはまだ決まりきっていないように見えるので、気になりますね。

## 感想

今後のTypeScriptのAnnex Bまわりのサポート内容や、ロジックの移行、パフォーマンスチューニングなどは気になるので、追ってみようかなと思います。TypeScriptほど大きいOSSプロジェクトのPRをしっかり見ることは初めてでしたが、パフォーマンス周りに敏感で、その書き方ってパフォーマンスに影響あるんだ、みたいなのをレビューから知れて面白かったです（例えばデフォルト引数はパフォーマンス上よくないらしい^[[https://github.com/microsoft/TypeScript/pull/55600#discussion_r1569073347](https://github.com/microsoft/TypeScript/pull/55600#discussion_r1569073347)]）。

[^1]: [https://github.com/microsoft/TypeScript/blob/main/src/compiler/diagnosticMessages.json#L1648-L1803](https://github.com/microsoft/TypeScript/blob/main/src/compiler/diagnosticMessages.json#L1648-L1803)
[^2]: [Add `invalid regular expression literal` error #3432 by Schmavery · Pull Request #4387 · microsoft/TypeScript](https://github.com/microsoft/TypeScript/pull/4387)
[^3]: [Added validation for regex literals via RegExp constructor by JoshuaKGoldberg · Pull Request #35957 · microsoft/TypeScript](https://github.com/microsoft/TypeScript/pull/35957)
[^4]: [Scanner | TypeScript Deep Dive](https://basarat.gitbook.io/typescript/overview/scanner)
[^5]: [https://github.com/microsoft/TypeScript/blob/c38569655bb151ec351c27032fbd3ef43b8856ba/src/compiler/scanner.ts#L4053-L4085](https://github.com/microsoft/TypeScript/blob/c38569655bb151ec351c27032fbd3ef43b8856ba/src/compiler/scanner.ts#L4053-L4085)
[^6]: [https://github.com/microsoft/TypeScript/pull/55600#pullrequestreview-2006009388](https://github.com/microsoft/TypeScript/pull/55600#pullrequestreview-2006009388)
[^7]: [https://github.com/microsoft/TypeScript/pull/55600#issuecomment-2067402238](https://github.com/microsoft/TypeScript/pull/55600#issuecomment-2067402238)
[^8]: [https://github.com/microsoft/TypeScript/blob/c38569655bb151ec351c27032fbd3ef43b8856ba/src/lib/README.md?plain=1#L13](https://github.com/microsoft/TypeScript/blob/c38569655bb151ec351c27032fbd3ef43b8856ba/src/lib/README.md?plain=1#L13)
[^9]: [https://github.com/microsoft/TypeScript/blob/867476e57a83dd6d8d6668308a7aa8ff14c422c4/src/compiler/scanner.ts#L2845-L2846](https://github.com/microsoft/TypeScript/blob/867476e57a83dd6d8d6668308a7aa8ff14c422c4/src/compiler/scanner.ts#L2845-L2846)
[^10]: [https://github.com/microsoft/TypeScript/pull/58295](https://github.com/microsoft/TypeScript/pull/58295)
[^11]: [https://github.com/microsoft/TypeScript/pull/58320](https://github.com/microsoft/TypeScript/pull/58320)
[^12]: [https://github.com/microsoft/TypeScript/issues/58287](https://github.com/microsoft/TypeScript/issues/58287)
